<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <title>Optics Data Viewer - SFM with Camera Animation</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />

  <!-- Potree CSS -->
  <link rel="stylesheet" href="build/potree/potree.css" />
  <link rel="stylesheet" href="libs/jquery-ui/jquery-ui.min.css" />
  <link rel="stylesheet" href="libs/openlayers3/ol.css" />
  <link rel="stylesheet" href="libs/spectrum/spectrum.css" />
  <link rel="stylesheet" href="libs/jstree/themes/mixed/style.css" />

  <style>
    html, body { margin:0; padding:0; height:100%; overflow:hidden; background:#000; }
    
    /* Loading + error */
    #loading {
      position:fixed; inset:0; display:flex; align-items:center; justify-content:center;
      background:rgba(10,10,15,.7); color:#e8eefc; font:15px system-ui,Segoe UI,Roboto,Arial;
      z-index:9999; flex-direction:column; gap:10px
    }
    #loading .spinner { width:40px; height:40px; border-radius:50%;
      border:3px solid rgba(255,255,255,.25); border-top-color:#fff; animation:spin 1s linear infinite; }
    @keyframes spin { to { transform:rotate(360deg) } }

    #error {
      position:absolute; top:12px; left:12px; right:12px;
      background:rgba(180,30,40,.9); color:#fff; padding:10px 12px; border-radius:8px; display:none; z-index:10000
    }

    .chip{
      position:absolute; bottom:12px; left:12px; background:rgba(20,20,30,.55); color:#fff;
      padding:6px 10px; border-radius:10px; font:13px system-ui; z-index:4
    }
  </style>
</head>
<body>

  <div class="potree_container" style="position: absolute; width: 100%; height: 100%; left: 0px; top: 0px;">
    <div id="potree_render_area">
    </div>
    <div id="potree_sidebar_container"> </div>
  </div>

  <div id="error"></div>
  <div id="loading"><div class="spinner"></div><div>Loading point cloud with camera animationâ€¦</div></div>
  <div class="chip" id="chip"></div>

  <!-- Libraries -->
  <script src="libs/jquery/jquery-3.1.1.min.js"></script>
  <script src="libs/spectrum/spectrum.js"></script>
  <script src="libs/jquery-ui/jquery-ui.min.js"></script>
  <script src="libs/other/BinaryHeap.js"></script>
  <script src="libs/tween/tween.min.js"></script>
  <script src="libs/d3/d3.js"></script>
  <script src="libs/proj4/proj4.js"></script>
  <script src="libs/openlayers3/ol.js"></script>
  <script src="libs/i18next/i18next.js"></script>
  <script src="libs/jstree/jstree.js"></script>

  <!-- Potree -->
  <script src="build/potree/potree.js"></script>
  <script src="libs/plasio/js/laslaz.js"></script>

  <script>
    // ---- Params
    const qs = new URLSearchParams(location.search);
    const src       = qs.get('src');                    // REQUIRED: cloud.js
    const title     = qs.get('title') || 'SFM Point Cloud';
    const chip      = document.getElementById('chip'); chip.textContent = title;

    const errorBox  = document.getElementById('error');
    const loading   = document.getElementById('loading');

    function showError(msg, details){
      errorBox.style.display = 'block';
      errorBox.innerHTML = `<strong>Couldn't load point cloud.</strong> ${msg}`
        + (details ? `<div style="opacity:.9;margin-top:6px;font-size:13px">${details}</div>` : '');
      console.error('Potree load error:', msg, details);
      loading.style.display = 'none';
    }

    if (!src) {
      showError('Missing <code>?src=</code> URL parameter.',
        'Pass a public HTTPS URL to <code>cloud.js</code> (Potree format).');
    } else {
      // Initialize viewer
      window.viewer = new Potree.Viewer(document.getElementById("potree_render_area"));
      
      viewer.setEDLEnabled(false);
      viewer.setFOV(60);
      viewer.setPointBudget(3_000_000);
      viewer.loadSettingsFromURL();
      viewer.setDescription(`
      SFM Point Cloud with Camera Animation<br>
      Create new animation paths via "Tools -> Navigation -> Camera Animation"<br>
      Modify and play animations via "Scene -> Objects -> Other -> [animation object]".
      `);
      
      // Load GUI immediately with sidebar visible
      viewer.loadGUI(() => {
        viewer.setLanguage('en');
        $("#menu_scene").next().show();
        $("#menu_tools").next().show();
        viewer.toggleSidebar();
        
        // Initialize export functionality in sidebar
        initializeSidebarExports();
      });
      
      // Load point cloud
      Potree.loadPointCloud(src, title, e => {
        let scene = viewer.scene;
        let pointcloud = e.pointcloud;
        
        let material = pointcloud.material;
        material.size = 1;
        material.pointSizeType = Potree.PointSizeType.ADAPTIVE;
        material.shape = Potree.PointShape.SQUARE;
        
        scene.addPointCloud(pointcloud);
        
        viewer.fitToScreen();
        loading.style.display = 'none';
        
        // Create default camera animation if this is an SFM dataset
        // Add a small delay to ensure everything is fully loaded
        setTimeout(() => {
          createDefaultCameraAnimation(pointcloud);
        }, 1000);
      });
    }

    // Create a default camera animation for SFM datasets
    function createDefaultCameraAnimation(pointcloud) {
      try {
        // Use the global THREE object (should be available from Potree)
        if (typeof THREE !== 'undefined') {
          const animation = new Potree.CameraAnimation(viewer);

          // Get the bounding box center and size for camera positions
          const box = pointcloud.boundingBox;
          const center = box.getCenter(new THREE.Vector3());
          const size = box.getSize(new THREE.Vector3());
          const maxDim = Math.max(size.x, size.y, size.z);

          // Create a circular camera path around the point cloud
          const radius = maxDim * 1.5;
          const height = center.z + size.z * 0.3;
          const numPoints = 6;

          for(let i = 0; i < numPoints; i++){
            const angle = (i / numPoints) * Math.PI * 2;
            const cp = animation.createControlPoint();

            // Position camera in a circle around the center
            cp.position.set(
              center.x + Math.cos(angle) * radius,
              center.y + Math.sin(angle) * radius,
              height
            );
            
            // Always look at the center
            cp.target.copy(center);
          }

          viewer.scene.addCameraAnimation(animation);
          
          // Add camera animation controls to the GUI with debugging
          console.log('Adding camera animation controls...');
          addCameraAnimationControls(animation);
        } else {
          console.log('THREE.js not available for camera animation');
        }
      } catch (err) {
        console.log('Camera animation not available:', err);
      }
    }

    // Add camera animation controls to the Potree GUI
    function addCameraAnimationControls(animation) {
      const addControls = () => {
        console.log('Adding camera animation controls to GUI...');
        try {
        let section = $(`
          <h3 id="menu_camera_anim" class="accordion-header ui-widget"><span>Camera Animation</span></h3>
          <div class="accordion-content ui-widget pv-menu-list"></div>
        `);
        let content = section.last();
        content.html(`
        <div class="pv-menu-list">
          <span id="animation_keyframes"></span>
          <span>
            <span>Time: </span><span id="lblTime">0.00</span> 
            <div id="sldTime"></div>
            <div style="margin-top: 8px;">
              <input name="play" type="button" value="Play Animation"/>
              <input name="stop" type="button" value="Stop"/>
            </div>
            <div style="margin-top: 12px; padding-top: 8px; border-top: 1px solid #333;">
              <div style="margin-bottom: 6px; font-weight: bold; color: #cfe;">Camera Track Management</div>
              <div style="margin-bottom: 4px;">
                <input name="saveTrack" type="button" value="Save Track" style="margin-right: 4px;"/>
                <input name="loadTrack" type="button" value="Load Track"/>
              </div>
              <div style="margin-bottom: 4px;">
                <input name="clearTrack" type="button" value="Clear Track" style="margin-right: 4px;"/>
                <input name="newTrack" type="button" value="New Track"/>
              </div>
              <input type="file" id="trackFileInput" accept=".json" style="display: none;"/>
            </div>
          </span>
        </div>
        `);

        const elPlay = content.find("input[name=play]");
        const elStop = content.find("input[name=stop]");
        const elSaveTrack = content.find("input[name=saveTrack]");
        const elLoadTrack = content.find("input[name=loadTrack]");
        const elClearTrack = content.find("input[name=clearTrack]");
        const elNewTrack = content.find("input[name=newTrack]");
        const elFileInput = content.find("#trackFileInput");

        elPlay.click(() => {
          animation.play();
        });
        elStop.click(() => {
          animation.stop();
        });

        // Save camera track to JSON file
        elSaveTrack.click(() => {
          saveCameraTrack(animation);
        });

        // Load camera track from JSON file
        elLoadTrack.click(() => {
          elFileInput.click();
        });

        // Clear all keyframes
        elClearTrack.click(() => {
          if (confirm('Are you sure you want to clear all keyframes?')) {
            clearCameraTrack(animation);
          }
        });

        // Create new empty track
        elNewTrack.click(() => {
          if (confirm('Create a new empty camera track? This will clear existing keyframes.')) {
            clearCameraTrack(animation);
          }
        });

        // Handle file input change
        elFileInput.on('change', function(e) {
          const file = e.target.files[0];
          if (file) {
            loadCameraTrack(animation, file);
          }
        });

        const elSlider = content.find('#sldTime');
        const elTimeLabel = content.find('#lblTime');
        elSlider.slider({
          value: 0,
          min: 0,
          max: 1,
          step: 0.001,
          slide: (event, ui) => { 
            animation.set(ui.value);
            elTimeLabel.text(ui.value.toFixed(2));
          }
        });

        const elKeyframes = content.find("#animation_keyframes");

        const updateKeyframes = () => {
          elKeyframes.empty();
          let index = 0;

          const addNewKeyframeItem = (index) => {
            let elNewKeyframe = $(`
              <div style="display: flex; margin: 0.2em 0em">
                <span style="flex-grow: 0;">
                  <img name="add" src="${Potree.resourcePath}/icons/add.svg" style="width: 1.5em; height: 1.5em"/>
                </span>
                <span style="flex-grow: 1"></span>
              </div>
            `);

            const elAdd = elNewKeyframe.find("img[name=add]");
            elAdd.click(() => {
              animation.createControlPoint(index);
            });

            elKeyframes.append(elNewKeyframe);
          };

          const addKeyframeItem = (index) => {
            let elKeyframe = $(`
              <div style="display: flex; margin: 0.2em 0em">
                <span style="flex-grow: 0;">
                  <img name="assign" src="${Potree.resourcePath}/icons/assign.svg" style="width: 1.5em; height: 1.5em"/>
                </span>
                <span style="flex-grow: 0;">
                  <img name="move" src="${Potree.resourcePath}/icons/circled_dot.svg" style="width: 1.5em; height: 1.5em"/>
                </span>
                <span style="flex-grow: 0; width: 1.5em; height: 1.5em"></span>
                <span style="flex-grow: 0; font-size: 1.2em">Keyframe ${index + 1}</span>
                <span style="flex-grow: 1"></span>
                <span style="flex-grow: 0;">
                  <img name="delete" src="${Potree.resourcePath}/icons/remove.svg" style="width: 1.5em; height: 1.5em"/>
                </span>
              </div>
            `);

            const elAssign = elKeyframe.find("img[name=assign]");
            const elMove = elKeyframe.find("img[name=move]");
            const elDelete = elKeyframe.find("img[name=delete]");

            elAssign.click(() => {
              const cp = animation.controlPoints[index];
              cp.position.copy(viewer.scene.view.position);
              cp.target.copy(viewer.scene.view.getPivot());
            });

            elMove.click(() => {
              const cp = animation.controlPoints[index];
              viewer.scene.view.position.copy(cp.position);
              viewer.scene.view.lookAt(cp.target);
            });

            elDelete.click(() => {
              const cp = animation.controlPoints[index];
              animation.removeControlPoint(cp);
            });

            elKeyframes.append(elKeyframe);
          };

          addNewKeyframeItem(index);

          for(const cp of animation.controlPoints){
            addKeyframeItem(index);
            index++;
            addNewKeyframeItem(index);
          }
        };

        updateKeyframes();

        animation.addEventListener("controlpoint_added", updateKeyframes);
        animation.addEventListener("controlpoint_removed", updateKeyframes);

        // Update time display during animation
        const updateTime = () => {
          if (animation.isPlaying) {
            const t = animation.t || 0;
            elTimeLabel.text(t.toFixed(2));
            elSlider.slider('value', t);
          }
          requestAnimationFrame(updateTime);
        };
        updateTime();

        section.first().click(() => content.slideToggle());
        section.insertBefore($('#menu_about'));
        console.log('Camera animation controls added successfully');
        } catch (error) {
          console.error('Error adding camera animation controls:', error);
        }
      };

      // Check if GUI is ready, or wait for it
      if (viewer.sidebar && viewer.sidebar.root) {
        addControls();
      } else {
        viewer.onGUILoaded(addControls);
      }
    }

    // Camera track management functions
    function saveCameraTrack(animation) {
      try {
        const trackData = {
          version: "1.0",
          created: new Date().toISOString(),
          title: title || "Camera Track",
          pointCloudSrc: src,
          duration: animation.duration || 10,
          controlPoints: []
        };

        // Export all control points
        for (let i = 0; i < animation.controlPoints.length; i++) {
          const cp = animation.controlPoints[i];
          trackData.controlPoints.push({
            index: i,
            position: cp.position.toArray(),
            target: cp.target.toArray(),
            time: cp.time || (i / (animation.controlPoints.length - 1))
          });
        }

        // Create and download the file
        const blob = new Blob([JSON.stringify(trackData, null, 2)], {type: 'application/json'});
        const url = URL.createObjectURL(blob);
        const a = document.createElement('a');
        a.href = url;
        a.download = `${(title || 'camera-track').replace(/\s+/g, '-').toLowerCase()}-${Date.now()}.json`;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);

        console.log('Camera track saved successfully');
        alert(`Camera track saved with ${trackData.controlPoints.length} keyframes`);
      } catch (error) {
        console.error('Error saving camera track:', error);
        alert('Error saving camera track: ' + error.message);
      }
    }

    function loadCameraTrack(animation, file) {
      const reader = new FileReader();
      reader.onload = function(e) {
        try {
          const trackData = JSON.parse(e.target.result);
          
          // Check if this is a camera track file (with controlPoints) or single camera position
          if (trackData.controlPoints && Array.isArray(trackData.controlPoints)) {
            // This is a proper camera track file
            console.log('Loading camera track with', trackData.controlPoints.length, 'keyframes');
            
            // Clear existing control points
            clearCameraTrack(animation);

            // Load control points
            for (const cpData of trackData.controlPoints) {
              if (cpData.position && cpData.target && cpData.position.length === 3 && cpData.target.length === 3) {
                const cp = animation.createControlPoint();
                cp.position.fromArray(cpData.position);
                cp.target.fromArray(cpData.target);
                if (cpData.time !== undefined) {
                  cp.time = cpData.time;
                }
              }
            }

            // Set duration if available
            if (trackData.duration) {
              animation.duration = trackData.duration;
            }

            console.log('Camera track loaded successfully');
            alert(`Camera track loaded with ${trackData.controlPoints.length} keyframes`);
            
            // Reset animation to beginning
            animation.set(0);
            
          } else if (trackData.position && trackData.target) {
            // This looks like a single camera position file - convert it to a single keyframe
            console.log('Converting single camera position to keyframe');
            
            if (confirm('This appears to be a single camera position. Create a single keyframe from this position?')) {
              // Clear existing control points
              clearCameraTrack(animation);
              
              // Create single keyframe from the camera position
              const cp = animation.createControlPoint();
              if (Array.isArray(trackData.position) && trackData.position.length === 3) {
                cp.position.fromArray(trackData.position);
              }
              if (Array.isArray(trackData.target) && trackData.target.length === 3) {
                cp.target.fromArray(trackData.target);
              }
              
              console.log('Single camera position converted to keyframe');
              alert('Single camera position loaded as keyframe');
              
              // Reset animation to beginning
              animation.set(0);
            } else {
              alert('Use the sidebar "Load Camera" button for single camera positions');
            }
            
          } else {
            throw new Error('Invalid file format - missing controlPoints array or camera position data');
          }
          
        } catch (error) {
          console.error('Error loading camera track:', error);
          alert('Error loading camera track: ' + error.message);
        }
      };
      reader.readAsText(file);
    }

    function clearCameraTrack(animation) {
      try {
        // Remove all control points
        const controlPoints = [...animation.controlPoints]; // Create a copy to avoid modification during iteration
        for (const cp of controlPoints) {
          animation.removeControlPoint(cp);
        }
        
        // Reset animation
        animation.set(0);
        animation.stop();
        
        console.log('Camera track cleared');
      } catch (error) {
        console.error('Error clearing camera track:', error);
        alert('Error clearing camera track: ' + error.message);
      }
    }

    // Initialize sidebar export functionality
    function initializeSidebarExports() {
      // Wait for sidebar to be fully loaded
      const checkSidebar = () => {
        const btnScreenshot = document.getElementById('btnExportScreenshot');
        const btnCamera = document.getElementById('btnExportCamera');
        const btnMeasurements = document.getElementById('btnExportMeasurements');
        const btnShareLink = document.getElementById('btnShareLink');
        const btnLoadCamera = document.getElementById('btnLoadCamera');
        const cameraFileInput = document.getElementById('cameraFileInput');

        if (btnScreenshot && btnCamera && btnMeasurements && btnShareLink && btnLoadCamera && cameraFileInput) {
          // Screenshot export
          btnScreenshot.onclick = () => {
            try {
              const dataURL = viewer.renderer.domElement.toDataURL('image/png');
              const a = document.createElement('a');
              a.href = dataURL;
              a.download = (title || 'sfm-screenshot') + '.png';
              document.body.appendChild(a);
              a.click();
              a.remove();
            } catch (err) {
              alert('Screenshot failed. Some browsers require special flags for WebGL capture.');
              console.error(err);
            }
          };

          // Camera export
          btnCamera.onclick = () => {
            const cameraData = getCameraState();
            const blob = new Blob([JSON.stringify(cameraData, null, 2)], {type: 'application/json'});
            const a = document.createElement('a');
            a.href = URL.createObjectURL(blob);
            a.download = (title || 'camera') + '.json';
            document.body.appendChild(a);
            a.click();
            a.remove();
          };

          // Measurements export
          btnMeasurements.onclick = () => {
            try {
              const out = [];
              const ms = (viewer.measuringTool.measurements || viewer.measuringTool.measures || []);
              for (const m of ms) {
                const pts = (m.points || []).map(p => p.position.toArray());
                out.push({ name: m.name || 'Measure', closed: !!m.closed, points: pts });
              }
              const blob = new Blob([JSON.stringify({ measurements: out }, null, 2)], {type: 'application/json'});
              const a = document.createElement('a');
              a.href = URL.createObjectURL(blob);
              a.download = (title || 'measurements') + '.json';
              document.body.appendChild(a);
              a.click();
              a.remove();
            } catch (err) {
              alert('No measurements found or export failed.');
              console.error(err);
            }
          };

          // Share link
          btnShareLink.onclick = async () => {
            const u = new URL(location.href.split('?')[0], location.href);
            const params = new URLSearchParams();
            params.set('src', src || '');
            params.set('title', title || 'SFM Point Cloud');
            u.search = params.toString();
            try {
              await navigator.clipboard.writeText(u.toString());
              alert('Viewer link copied to clipboard');
            } catch {
              prompt('Copy link:', u.toString());
            }
          };

          // Load camera
          btnLoadCamera.onclick = () => {
            cameraFileInput.click();
          };

          cameraFileInput.onchange = (e) => {
            const file = e.target.files[0];
            if (file) {
              const reader = new FileReader();
              reader.onload = (e) => {
                try {
                  const cameraData = JSON.parse(e.target.result);
                  setCameraState(cameraData);
                  alert('Camera position loaded successfully');
                } catch (err) {
                  alert('Invalid camera file: ' + err.message);
                }
              };
              reader.readAsText(file);
            }
          };

        } else {
          // Retry after a short delay
          setTimeout(checkSidebar, 100);
        }
      };

      checkSidebar();
    }

    // Camera state management functions
    function getCameraState() {
      try {
        const v = viewer.scene.view;
        const cam = viewer.scene.getActiveCamera();
        
        // Get pivot/target - try multiple methods
        let target = [0, 0, 0];
        if (v.getPivot) {
          const pivot = v.getPivot();
          target = pivot.toArray ? pivot.toArray() : [pivot.x, pivot.y, pivot.z];
        } else if (v.pivot) {
          target = v.pivot.toArray ? v.pivot.toArray() : [v.pivot.x, v.pivot.y, v.pivot.z];
        }
        
        const cameraState = {
          position: cam.position.toArray(),
          target: target,
          fov: cam.fov || v.fov || 60
        };
        
        // Add view-specific properties if available
        if (v.yaw !== undefined) cameraState.yaw = v.yaw;
        if (v.pitch !== undefined) cameraState.pitch = v.pitch;
        if (v.radius !== undefined) cameraState.radius = v.radius;
        
        return cameraState;
      } catch (error) {
        console.error('Error getting camera state:', error);
        // Fallback - just get basic camera info
        const cam = viewer.scene.getActiveCamera();
        return {
          position: cam.position.toArray(),
          target: [0, 0, 0],
          fov: cam.fov || 60
        };
      }
    }

    function setCameraState(state) {
      try {
        console.log('Setting camera state:', state);
        const v = viewer.scene.view;
        const cam = viewer.scene.getActiveCamera();
        
        // Set position first
        if (state.position && Array.isArray(state.position) && state.position.length === 3) {
          cam.position.set(state.position[0], state.position[1], state.position[2]);
          console.log('Camera position set to:', state.position);
        }
        
        // Set FOV
        if (typeof state.fov === 'number') {
          cam.fov = state.fov;
          cam.updateProjectionMatrix();
          console.log('Camera FOV set to:', state.fov);
        }
        
        // Set view properties (yaw, pitch, radius) - these are Potree-specific
        if (typeof state.yaw === 'number' && v.yaw !== undefined) {
          v.yaw = state.yaw;
          console.log('View yaw set to:', state.yaw);
        }
        if (typeof state.pitch === 'number' && v.pitch !== undefined) {
          v.pitch = state.pitch;
          console.log('View pitch set to:', state.pitch);
        }
        if (typeof state.radius === 'number' && v.radius !== undefined) {
          v.radius = state.radius;
          console.log('View radius set to:', state.radius);
        }
        
        // Set target/pivot - try multiple approaches
        if (state.target && Array.isArray(state.target) && state.target.length === 3) {
          const targetVector = new THREE.Vector3(state.target[0], state.target[1], state.target[2]);
          
          // Try Potree's view methods first
          if (v.lookAt) {
            v.lookAt(targetVector);
            console.log('Used view.lookAt for target:', state.target);
          } else if (v.setPivot) {
            v.setPivot(targetVector);
            console.log('Used view.setPivot for target:', state.target);
          } else {
            // Fallback to camera lookAt
            cam.lookAt(targetVector);
            console.log('Used camera.lookAt for target:', state.target);
          }
        }
        
        // Force update and render
        if (v.update) {
          v.update();
        }
        
        // Ensure the renderer updates
        if (viewer.setNeedsRedraw) {
          viewer.setNeedsRedraw();
        }
        
        // Alternative: force immediate render
        if (viewer.render) {
          viewer.render();
        }
        
        console.log('Camera state applied successfully');
        
      } catch (error) {
        console.error('Error in main setCameraState:', error);
        
        // Comprehensive fallback approach
        try {
          console.log('Attempting fallback camera positioning...');
          const cam = viewer.scene.getActiveCamera();
          
          if (state.position && Array.isArray(state.position) && state.position.length === 3) {
            cam.position.set(state.position[0], state.position[1], state.position[2]);
          }
          
          if (state.target && Array.isArray(state.target) && state.target.length === 3) {
            cam.lookAt(new THREE.Vector3(state.target[0], state.target[1], state.target[2]));
          }
          
          if (typeof state.fov === 'number') {
            cam.fov = state.fov;
            cam.updateProjectionMatrix();
          }
          
          // Force render
          if (viewer.setNeedsRedraw) {
            viewer.setNeedsRedraw();
          } else if (viewer.render) {
            viewer.render();
          }
          
          console.log('Fallback camera positioning successful');
          
        } catch (fallbackError) {
          console.error('Fallback camera setting failed:', fallbackError);
          throw new Error('Could not set camera position - both main and fallback methods failed');
        }
      }
    }
  </script>
</body>
</html>
